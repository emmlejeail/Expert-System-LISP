; Pour Tester:
; appelez la fonction (start)
; Repondez au questions par une seule des réponse proposé entre parentheses
; Par exemple pour la question sur les interet: si vous aimmez la danse et la musique (et que vous preferez la danse) repondez danse la premiere fois que la question est posé, puis musique, puis fin pour passer à la question suivante.
; Lorsqu'une asso vous est proposé, repondez oui pour arreter la recherche, non pour continuer la recherche en réinitialisant le score de l'asso, ou c pour continuer la recherche sans réinitialiser le score de l'asso
; A la fin, lorseque le systeme arrete de poser des question (quand une asso a étét choisi ou que le systeme n'a plus rien à faire) lancez la fontion (topasso) pour voir le score des asso en fonction de vos réponse.

(defvar *BR*)
(defvar *BF*)
(defvar *BQ*)
(defvar *trouve*)

(setf *BR* '(
             (R_1 ((= etudiant interet (? . interet) (? . etuP)) (= asso (? . asso) interet (? . interet) (? . assoP))) ((recom (? . asso) (? . etuP) (? . assoP))))
             (R_2 ((= etudiant interet (? . interet) (? . prop) (? . val) (? . etuP)) (= asso (? . asso) interet (? . interet) (? . prop) (? . val) (? . assoP))) ((recom (? . asso) (? . etuP) (? . assoP))))
             (R_2instru ((= etudiant interet musique instrument (? . instru) niveau (? . niveau) (? . etuP)) (= asso (? . asso) interet musique instrument (? . instru) (? . assoP)) (= asso (? . asso) interet musique instrument * niveau (? . niveau))) ((recom (? . asso) (? . etuP) (? . assoP))))
             (R_3instru ((= etudiant interet musique instrument pratique (? . prat) (? . etuP)) (= asso (? . asso) interet musique instrument pratique (? . prat) (? . assoP))) ((recom (? . asso) (? . etuP) (? . assoP))))
             
             (Q_1 ((! etudiant interet (? . interet) (? . etuP))) ((demander (etudiant interet))))
               
             (Q_2 ((= etudiant interet musique (? . etuP))) ((demander (etudiant interet musique style)) (demander (etudiant interet musique instrument))))
             (Q_3 ((= etudiant interet musique instrument (? . instru) niveau (? . niveau) (? . etuP)) (! etudiant interet musique instrument pratique (? . fp) (? . etuP))) ((demander (etudiant interet musique instrument pratique))))
               
             (Q_2 ((= etudiant interet danse (? . etuP))) ((demander (etudiant interet danse style)) (demander (etudiant interet danse pratique))))
             (Q_2 ((= etudiant interet danse style (? . style) (? . etuP))) ((demander (etudiant interet danse style (? . style) niveau))))
             ))

(setf *BQ* '(
             ((etudiant interet) "Quels sont tes interets ?" multiple)
             
             ((etudiant interet musique style) "Quels styles de musique aimes-tu ?" multiple)
             ((etudiant interet musique instrument pratique) "Comment aimes tu pratiquer ces instruments ?" multiple)
             
             ((etudiant interet danse style) "Quels styles de danse aimes-tu ?" multiple)
             ((etudiant interet danse style) "Comment aimes-tu pratiquer la danse ?" multiple)
             ))

(defun start ()
  (setf *trouve* nil)
  
  (setf *BF* '(
             (asso Stravaganza interet musique 0.3)
             (asso Stravaganza interet musique style classique 0.25)
             (asso Stravaganza interet musique instrument violon 0.15)
             (asso Stravaganza interet musique instrument pratique orchestre 0.3)
             (asso Stravaganza interet musique instrument * niveau moyen)
             (asso Stravaganza interet musique instrument * niveau confirme)
             (asso Stravaganza score 0)
               
             (asso Larsen interet musique 0.3)
             (asso Larsen interet musique style rock 0.25)
             (asso Larsen interet musique instrument guitare 0.1)
             (asso Larsen interet musique instrument chant 0.1)
             (asso Larsen interet musique instrument batterie 0.1)
             (asso Larsen interet musique instrument basse 0.1)
             (asso Larsen interet musique instrument piano 0.1)
             (asso Larsen interet musique instrument pratique groupe 0.3)
             (asso Larsen interet musique instrument * niveau moyen)
             (asso Larsen interet musique instrument * niveau confirme)
             (asso Larsen score 0)
             
             (asso PianoUT interet musique 0.3)
             (asso PianoUT interet musique style classique 0.15)
             (asso PianoUT interet musique instrument piano 0.3)
             (asso PianoUT interet musique instrument pratique individuelle 0.25)
             (asso PianoUT interet musique instrument * niveau debutant)
             (asso PianoUT interet musique instrument * niveau moyen)
             (asso PianoUT interet musique instrument * niveau confirmer)
             (asso PianoUT score 0)
               
             (asso Acoustic interet musique 0.3)
             (asso Acoustic interet musique style classique 0.1)
             (asso Acoustic interet musique instrument guitare 0.3)
             (asso Acoustic interet musique instrument pratique individuelle 0.15)
             (asso Acoustic interet musique instrument pratique groupe 0.15)
             (asso Acoustic interet musique instrument * niveau debutant)
             (asso Acoustic interet musique instrument * niveau moyen)
             (asso Acoustic interet musique instrument * niveau confirmer)
             (asso Acoustic score 0)

             (asso Choruts interet musique 0.3)
             (asso Choruts interet musique style variete 0.1)
             (asso Choruts interet musique instrument chant 0.3)
             (asso Choruts interet musique instrument pratique choral 0.3)
             (asso Choruts interet musique instrument * niveau basique)
             (asso Choruts interet musique instrument * niveau moyen)
             (asso Choruts interet musique instrument * niveau confirme)
             (asso Choruts score 0)
               
             (asso AlaRUtc interet musique 0.3)
             (asso AlaRUtc interet musique style fanfare 0.3)
             (asso AlaRUtc interet musique instrument saxophone 0.15)
             (asso AlaRUtc interet musique instrument trompette 0.15)
             (asso AlaRUtc interet musique instrument tambour 0.15)
             (asso AlaRUtc interet musique instrument flute 0.15)
             (asso AlaRUtc interet musique instrument pratique groupe 0.25)
             (asso AlaRUtc interet musique instrument * niveau debutant)
             (asso AlaRUtc interet musique instrument * niveau moyen)
             (asso AlaRUtc interet musique instrument * niveau confirme)
             (asso AlaRUtc score 0)
               
             (asso PicNRock interet danse 0.3)
             (asso PicNRock interet musique style rock 0.2)
             (asso PicNRock interet danse style rock 0.3)
             (asso PicNRock interet danse style rock niveau debutant 0.2)
             (asso PicNRock interet danse style rock niveau moyen 0.15)
             (asso PicNRock interet danse style rock niveau confirme 0.1)
             (asso PicNRock interet danse pratique couple 0.2)
             (asso PicNRock score 0)
               
             (asso Coincidence interet danse 0.3)
             (asso Coincidence interet danse style modern_jazz 0.3)
             (asso Coincidence interet danse style modern_jazz niveau moyen 0.15)
             (asso Coincidence interet danse style modern_jazz niveau confirme 0.15)
             (asso Coincidence interet danse pratique groupe 0.25)
             (asso Coincidence score 0)
               
             (asso BreakDance interet danse 0.3)
             (asso BreakDance interet danse style breakdance 0.3)
             (asso BreakDance interet danse style breakdance niveau debutant 0.15)
             (asso BreakDance interet danse style breakdance niveau moyen 0.15)
             (asso BreakDance interet danse style breakdance niveau confirme 0.15)
             (asso BreakDance interet danse pratique individuelle 0.15)
             (asso BreakDance interet danse pratique groupe 0.15)
             (asso BreakDance score 0)
             ))
  (dolist (regle (regles_candidates))
    (appliqueRegle regle)
  )
)

(defun reponsePossible (fait)
  (let (l_matchings l_reponses)
    (setq l_matchings (fmatching (append '(asso (? . asso)) (cdr fait) '((? . reponse) (? . assoP)))))
    (dolist (matching l_matchings l_reponses)
      (pushnew (cdr (assoc 'reponse matching)) l_reponses)    
    )
  )  
)

(defun demander (param)
  (let ((fait (car param)) (l_faits '()) (question (assoc (car param) *BQ* :test #'equal)))
    (cond
      ((equal fait '(etudiant interet musique instrument))
        (do ((etuP 1 (/ etuP 0.75))) (nil)
          (if *trouve* (return-from nil nil))
          (format t "De quels instruments joues-tu ? ~S~%" (reponsePossible fait))
          (setq rep (read))
          (if (eq rep 'fin) (return-from nil nil))
          (format t "A quel niveau ? (debutant moyen confirme) ~%")
          (setq repNiveau (read))
          (setq l_faits (append l_faits (list (append fait (list rep 'niveau repNiveau etuP)))))
        )
      )
      (question
        (if (equal (caddr question) 'unique)
          (progn 
            (format t "~A ~S~%" (cadr question) (reponsePossible fait))
            (setq rep (read))
            (setq l_faits (append l_faits (list (append fait (list rep 1)))))
          )
          (progn
            (do ((etuP 1 (/ etuP 0.75))) (nil)
              (if *trouve* (return-from nil nil))
              (format t "~A ~S~%" (cadr question) (reponsePossible fait))
              (setq rep (read))
              (if (eq rep 'fin) (return-from nil nil))
              (setq l_faits (append l_faits (list (append fait (list rep etuP)))))
            )
          )
        )  
      )
      (t
        (do ((etuP 1 (/ etuP 0.75))) (nil)
          (if *trouve* (return-from nil nil))
          (format t "~S ? ~S~%" fait (reponsePossible fait))
          (setq rep (read))
          (if (eq rep 'fin) (return-from nil nil))
          (setq l_faits (append l_faits (list (append fait (list rep etuP)))))
        )
      ) 
    )
    (dolist (fait l_faits)
      (ajoutFait fait)
    )
  )
)

(defun recupVar (asso var)
  (cdr (assoc 'var (car (fMatching (list 'asso asso var '(? . var))))))
)

(defun recom (param) 
  (let (pointeur (asso (car param)) (etuP (cadr param)) (assoP (caddr param)))
    (setq pointeur (car (member (list 'asso asso 'score (recupVar asso 'score)) *BF* :test #'equal)))
    (setf (nth 3 pointeur) (+ (* etuP assoP) (nth 3 pointeur)))
    (if (> (recupVar asso 'score) 1)
      (proposer asso)
    )
  )
)

(defun topAsso ()
  (let (scores)
    (dolist (asso (fMatching '(asso (? . asso) score (? . score))))
      (push (cons (cdr (assoc 'asso asso)) (cdr (assoc 'score asso))) scores)
    )
    (setq scores (sort scores #'(lambda (x y) (> (cdr x) (cdr y)))))
    scores
  )
)

(defun proposer (asso)
  (format t "~S est fait pour toi (score ~4,2F) ! Non ? " asso (recupVar asso 'score))
  (setq rep (read))
  (cond
    ((eq rep 'non) 
      (progn
        (setq pointeur (car (member (list 'asso asso 'score (recupVar asso 'score)) *BF* :test #'equal)))
        (setf (nth 3 pointeur) 0)
      )
    ) 
    ((eq rep 'oui)
      (setq *trouve* t)
    )
  )
)

(defun appliqueRegle (regle)
  (dolist (conclusion (caddr regle))
    (case (car conclusion)
      (+ (ajoutFait (cdr conclusion)))
      (otherwise (funcall (car conclusion) (cdr conclusion)))
    )
  )
)

(defun ajoutFait (fait)
  (if (not (member fait *BF* :test #'equal))
    (progn
      (push fait *BF*)
      (dolist (regle (regles_candidates))
        (if (member (cons '= fait) (cadr regle) :test #'equal)
          (appliqueRegle regle)
        )
      )
      t
    )
  )
)
  
(defun fMatching (pattern)
  (let (l_matchings)
    (dolist (fait *BF* l_matchings)
      (let ((atoms_ok t) (l_vars '()))
        (do ((l_pAtoms pattern (cdr l_pAtoms)) (l_fAtoms fait (cdr l_fAtoms))) ((not (and (or l_pAtoms l_fAtoms) atoms_ok)) atoms_ok)
          (if (not (and l_pAtoms l_fAtoms))
            (setq atoms_ok nil)
            (if (and (listp (car l_pAtoms)) (equal (caar l_pAtoms) '?) (car l_fAtoms))
              (push (cons (cdar l_pAtoms) (car l_fAtoms)) l_vars)
              (if (not (equal (car l_pAtoms) (car l_fAtoms)))
                (setq atoms_ok nil)
              )
            )
          )  
        )
        (if atoms_ok
          (push l_vars l_matchings)
        )
      )
    )
  )
)

(defun evalVar (list l_vars)
  (cons (if (listp (car list))
          (if (equal (caar list) '?)    
            (let ((val (cdr (assoc (cdar list) l_vars)))) (if val val (car list)))
            (evalVar (car list) l_vars)
          )
          (car list)
        )
        (if (cdr list) (evalVar (cdr list) l_vars) nil)
  )
)

(defun rMatching (l_premisses)
  (let (l_matchings (l_fMatchings (fMatching (cdar l_premisses))))
    (case (caar l_premisses)
      (! (setq l_fMatchings (if l_fMatchings nil (list nil))))
    )
    (if (cdr l_premisses)
      (dolist (fMatching l_fMatchings l_matchings)
        (dolist (matching (rMatching (evalVar (cdr l_premisses) fMatching)))
          (push (append fMatching matching) l_matchings)
        )
      )
      l_fMatchings
    )
  )
)

(defun regles_candidates ()
  (let (l_regles_c)
    (dolist (regle *BR* (reverse l_regles_c))
      (dolist (matching (rMatching (cadr regle)))
        (push (evalVar regle matching) l_regles_c)
      )
    )
  )
)